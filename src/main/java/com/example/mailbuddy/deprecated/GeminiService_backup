package com.example.mailbuddy.deprecated;

import com.example.mailbuddy.dto.SummaryDto;
import com.example.mailbuddy.entity.Gmail;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;

@Service
public class GeminiService_backup {

    @Value("${gemini.api.key}")
    private String apiKey;

    // 예) https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent
    @Value("${gemini.api.url}")
    private String apiUrl;

    private final WebClient webClient = WebClient.create();
    private final ObjectMapper om = new ObjectMapper();
    private static final ZoneId KST = ZoneId.of("Asia/Seoul");

    // 프롬프트 + 입력 텍스트 -> Gemini 호출 -> JSON 파싱 -> DTO
    public SummaryDto summarizeToDto(String text) {
        String prompt =
                "당신은 이메일 내용을 분석하여 캘린더 이벤트에 필요한 핵심 정보를 정확히 추출하는 전문 AI 비서입니다."+
                        "반드시 **오직 하나의 JSON 객체만** 반환하세요. JSON 바깥의 텍스트/설명/코드펜스는 금지합니다." +

                        "[목표]"+ "일정 추가용이기 때문에 캘린더에 추가할 내용이 아닌 광고, 그냥 알림 메일은 모두 그냥 지우고 요약하지 않는다."+
                        "- title: 메일 제목을 그대로 쓰지 말고, 메일의 제목+내용을 보고 '내 일정' 형태로 한 줄 요약 (예: 홍길동과 점심 미팅)"+
                        "- time: 가능하면 'YYYY-MM-DDTHH:mm' (불가하면 null)" +
                        "- place: 장소명/지명/주소 중 하나 (불가하면 null)" +
                        "- name/email: 발신자 이름/이메일 " +

                        "[분류 규칙]" +
                        "광고/프로모션/공지/보안 알림/영수증/배송/구독 확인 등 '일정 아님'이면 모든 필드를 null로 설정합니다." +

                        "[중요: description(=notes) 작성 규칙]" +
                        " description은 원문을 복붙하지 말고, **title/time/place/name/email에 이미 들어간 정보를 제외한 추가로 알아야 할 포인트만** 간략 요약합니다." +
                        " 포함할 것: 함께 만나는 사람, 준비물, 주의사항, 변경사항, 액션아이템(할 일), 주최측 요청사항 등." +
                        " **한국어**로 간단히 작성합니다. (원문이 영어/외국어여도 한국어로 요약) " +
                        " 형식: 불릿 1~3개, 각 불릿은 12단어(또는 60자) 이내의 짧은 문장." +
                        "**포함 금지**: 긴 원문 인용, 이메일 서명/주소록/광고문구, ‘Subject:’, ‘From:’, ‘내용:’ 같은 라벨, URL 나열." +
                        " **중복 금지**: title/time/place/name/email에 이미 들어간 정보는 다시 쓰지 않습니다." +
                        " 적을 내용이 없다면 description(notes)은 **null**로 둡니다. "+
                        "{\n" +
                        "  \"title\": \"string|null\",\n" +
                        "  \"time\": \"YYYY-MM-DDTHH:mm|null\",\n" +
                        "  \"place\": \"string|null\",\n" +
                        "  \"notes\": \"string|null\",\n" +
                        "  \"name\": \"string|null\",\n" +
                        "  \"email\": \"string|null\",\n" +
                        "}\n\n" +
                        "이메일 데이터:\n\n" + text;

        Map<String, Object> body = Map.of(
                "contents", List.of(
                        Map.of("role", "user", "parts", List.of(Map.of("text", prompt)))
                )
        );

        // 예외 없는 안전 로그
        System.out.println("[Gemini REQUEST] " + safeJson(body));
        System.out.println("[Gemini URL] " + apiUrl);

        // v1: generationConfig 사용 금지. 에러 시 예외 던지지 않고 빈 맵으로 진행.
        Map<?, ?> response = webClient.post()
                .uri(apiUrl + "?key=" + apiKey)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(body)
                .retrieve()
                .bodyToMono(Map.class)
                .onErrorReturn(Collections.emptyMap())
                .block();

        var candidates = (List<?>) (response != null ? response.get("candidates") : null);
        if (candidates == null || candidates.isEmpty()) return new SummaryDto();

        var first = (Map<?, ?>) candidates.get(0);
        var content = (Map<?, ?>) first.get("content");

        // parts 널/타입 방어
        List<?> parts = null;
        if (content != null) {
            Object raw = content.get("parts");
            if (raw instanceof List<?>) parts = (List<?>) raw;
        }
        if (parts == null || parts.isEmpty()) return new SummaryDto();

        // 모든 parts의 text 이어붙이기
        StringBuilder sb = new StringBuilder();
        for (Object o : parts) {
            if (o instanceof Map<?, ?> m) {
                Object t = m.get("text");
                if (t instanceof String s && !s.isBlank()) {
                    sb.append(s).append('\n');
                }
            }
        }
        String json = sb.toString();

        System.out.println("[Gemini RAW] " + json);
        json = stripToJson(json);
        System.out.println("[Gemini JSON] " + json);

        if (json.isBlank() || json.charAt(0) != '{') {
            return new SummaryDto();
        }

        try {
            return om.readValue(json, SummaryDto.class);
        } catch (Exception e) {
            System.err.println("[Gemini JSON PARSE ERROR] " + e.getMessage());
            return new SummaryDto();
        }
    }

    // Gmail 엔티티 -> 이메일 블록 텍스트 -> 요약 DTO
    public SummaryDto summarizeFromGmail(Gmail gmail) {
        String emailBlock = toEmailBlock(gmail);
        return summarizeToDto(emailBlock);
    }

    // ----- helpers -----

    // Gmail 엔티티를 프롬프트용 블록으로 변환 (본문 길면 앞/뒤만 유지)
    private String toEmailBlock(Gmail gmail) {
        ZonedDateTime zdt = gmail.getReceivedTime() != null
                ? gmail.getReceivedTime().atZone(KST)
                : ZonedDateTime.now(KST);
        DateTimeFormatter rfcLike = DateTimeFormatter.ofPattern("EEE, d MMM yyyy HH:mm:ss Z", Locale.ENGLISH);
        String received = zdt.format(rfcLike);

        String content = nz(gmail.getContent());
        // 본문이 너무 길면 앞/뒤만 유지 (토큰 초과 방지)
        if (content.length() > 8000) {
            content = content.substring(0, 4000) + "\n...\n" + content.substring(content.length() - 4000);
        }

        return """
                [발신자 이름] %s
                [발신자 이메일] %s
                [받은 시간] %s
                [제목] %s
                [내용] %s
                """.formatted(
                nz(gmail.getSenderName()),
                nz(gmail.getSenderEmail()),
                received,
                nz(gmail.getSubject()),
                content
        );
    }

    private static String nz(String s) { return s == null ? "" : s; }

    // 모델이 코드펜스/설명을 섞어도 JSON 본체만 추출
    private static String stripToJson(String s) {
        String t = s == null ? "" : s.trim();
        if (t.isEmpty()) return t;
        if (t.startsWith("```")) {
            int first = t.indexOf('{');
            int last = t.lastIndexOf('}');
            if (first >= 0 && last > first) return t.substring(first, last + 1);
        }
        int first = t.indexOf('{');
        int last = t.lastIndexOf('}');
        if (first >= 0 && last > first) return t.substring(first, last + 1);
        return t;
    }

    // 다양한 포맷을 KST LocalDateTime으로 파싱 (엔티티 저장 시 사용)
    public static LocalDateTime parseEventTimeKst(String s) {
        if (s == null || s.isBlank()) return null;
        try { // Offset/Zone 포함
            return ZonedDateTime.parse(s).withZoneSameInstant(KST).toLocalDateTime();
        } catch (Exception ignore) {}
        try { // 2025-11-12T16:00[:ss]
            return LocalDateTime.parse(s, DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm[:ss]"));
        } catch (Exception ignore) {}
        try { // 2025-11-12 16:00[:ss]
            return LocalDateTime.parse(s, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm[:ss]"));
        } catch (Exception ignore) {}
        try { // 2025/11/12 16:00[:ss]
            return LocalDateTime.parse(s, DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm[:ss]"));
        } catch (Exception ignore) {}
        return null;
    }

    // 예외 없는 안전 JSON 로깅
    private String safeJson(Object o) {
        try { return om.writeValueAsString(o); }
        catch (Exception e) { return String.valueOf(o); }
    }
}
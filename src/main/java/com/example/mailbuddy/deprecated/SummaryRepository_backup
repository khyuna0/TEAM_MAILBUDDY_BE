package com.example.mailbuddy.repository;


import com.example.mailbuddy.entity.Summary;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;
import java.time.LocalDateTime;
import java.util.Optional;

public interface SummaryRepository extends JpaRepository<Summary, Long> {

    //이미 요약한 내용 중복들어가지 않게 처리  -> gmail_id 입력해서 요약 불러오는 경우 (여러번 누르면 똑같은 내용 쌓임)
    boolean existsByGmail_Id(Long gmailId);
    Optional<Summary> findFirstByGmail_Id(Long gmailId);

    // 요약된 메일 전체에서 발신자 이름, 발신자 이메일 가져와서 요약된 메일 많이 보낸 순으로 정렬하기
    // Object[] 배열엔 [senderEmail, senderName, mailCount]
    @Query("SELECT s.senderEmail, s.senderName, COUNT(s) as mailCount " +
            "FROM Summary s GROUP BY s.senderEmail, s.senderName " +
            "ORDER BY mailCount DESC")
    List<Object[]> findSendersWithMailCountOrderByCountDesc();
    // Native Query
//    @Query(value = "SELECT sender_email, sender_name, COUNT(*) as mail_count " +
//            "FROM gmail GROUP BY sender_email, sender_name " +
//            "ORDER BY mail_count DESC", nativeQuery = true)
//    List<Object[]> findSendersWithMailCountNative();

    // 로그인한 유저 기준, 발신자 이름, 발신자 이메일 가져와서 요약된 메일 많이 보낸 순으로 정렬하기
    // Object[] 배열엔 [senderEmail, senderName, mailCount]
    @Query("SELECT s.senderEmail, s.senderName, COUNT(s) AS mailCount " +
            "FROM Summary s " +
            "JOIN s.gmail g " +
            "WHERE g.user.id = :userId " +
            "GROUP BY s.senderEmail, s.senderName " +
            "ORDER BY mailCount DESC")
    List<Object[]> findSendersByUserIdWithMailCountOrderByCountDesc(Long userId);


    List<Summary> findAllByGmail_User_IdAndEventTimeBetweenOrderByEventTimeAsc(
            Long userId,
            LocalDateTime start,
            LocalDateTime end
    );

    // userId + 월 범위: 날짜별 개수(뱃지)  — eventTime 없으면 createdAt로 보정
    @Query("""
      select function('date', coalesce(s.eventTime, s.createdAt)) as day, count(s)
      from Summary s
      join s.gmail g
      where g.user.id = :userId
        and coalesce(s.eventTime, s.createdAt) >= :start
        and coalesce(s.eventTime, s.createdAt) <  :end
      group by function('date', coalesce(s.eventTime, s.createdAt))
    """)
    List<Object[]> countByUserGroupedByDay(
            @Param("userId") Long Id,
            @Param("start") LocalDateTime start,
            @Param("end")   LocalDateTime end
    );

    // 로그인한 유저의 아이디를 통해서 요약된 시간 기준 내림차순으로 모든 요약 메일 가져오기
    List<Summary> findAllByGmail_User_IdOrderByCreatedAtDesc(Long userId);

    //전체리스트 -> 최신순
    List<Summary> findAllByOrderByCreatedAtDesc();
}
